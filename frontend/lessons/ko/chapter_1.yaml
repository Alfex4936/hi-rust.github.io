- title: Chapter 1 - The Basics
  source: >-
    /ferris_lofi.png
  content_markdown: >
    무슨 언어를 배우든 똑같이 기본부터 살펴보겠습니다. (변수, 함수, 클래스 등)


    Rust 언어 비공식이지만 거의 흔하게 쓰이는 마스코트, 게(crab)의 이름은 **Ferris** 입니다.


    %rust%
    let ferris = crab!("I'm mascot")

    println!("Hello, Rustacean!");
    %end%


    또한 Rust를 사용하거나, 기여하거나 관심이 있는 사람들을 **Rustacean**[러스테이션] 라고 부릅니다.
- title: The Rust Playground
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20println!(%22Welcome%20to%20the%20playground!%20You%20can%20modify%20the%20code%20in%20here.%22)%3B%0A%7D%0A
  content_markdown: >
    이 웹사이트에서는 [Rust
    Playground](https://play.rust-lang.org) 를 사용하여 온라인에서 직접 실행해 볼 수 있습니다.


    우측에서 보다시피 <code>println()</code>도 아닌 <code>println!()</code> 와 같은 코드를 사용하여 stdout에 출력하는 것을 볼 수 있습니다.


    `!` 이것은 매크로 (Macro)라는 Rust 언어의 특별한 기능 중 하나인데 우선은 생김새만 알고 나중에 뭔지 알아보겠습니다.


    Rust 언어는 쉽게 작성할 수 있도록 (syntactic sugar) 도와주지만 사실은 컴파일러가 아래처럼 처리합니다.


    (`cargo inspect` 명령어)


    %rust%
    #![feature(prelude_import)]


    #[prelude_import]

    use std::prelude::rust_2018::*;


    #[macro_use]

    extern crate std;


    fn main() {
        {
            ::std::io::_print(format_args!("Welcome to the playground! You can modify the code in here.\n"));
        };
    }
    %end%

- title: 변수
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&code=fn%20main()%20%7B%0A%20%20%20%20%2F%2F%20let%20%ED%82%A4%EC%9B%8C%EB%93%9C%EB%A5%BC%20%EC%82%AC%EC%9A%A9%ED%95%98%EC%97%AC%20%EB%B3%80%EC%88%98%EB%A5%BC%20%EC%84%A0%EC%96%B8%ED%95%A9%EB%8B%88%EB%8B%A4.%0A%20%20%20%20let%20x%20%3D%205%3B%20%2F%2F%20x%EC%97%90%205%EB%9D%BC%EB%8A%94%20%EA%B0%92%EC%9D%84%20%ED%95%A0%EB%8B%B9%ED%95%A9%EB%8B%88%EB%8B%A4.%0A%20%20%20%20let%20y%3A%20f32%20%3D%203.14%3B%20%2F%2F%20y%EC%97%90%203.14%EB%9D%BC%EB%8A%94%20%EA%B0%92%EC%9D%84%20%ED%95%A0%EB%8B%B9%ED%95%98%EB%A9%B0%2C%20f32%20%ED%83%80%EC%9E%85%EC%9D%84%20%EB%AA%85%EC%8B%9C%EC%A0%81%EC%9C%BC%EB%A1%9C%20%EC%A7%80%EC%A0%95%ED%95%A9%EB%8B%88%EB%8B%A4.%0A%0A%20%20%20%20%2F%2F%20Rust%EB%8A%94%20%EB%8C%80%EB%B6%80%EB%B6%84%EC%9D%98%20%EA%B2%BD%EC%9A%B0%20%EB%B3%80%EC%88%98%EC%9D%98%20%ED%83%80%EC%9E%85%EC%9D%84%20%EC%B6%94%EB%A1%A0%ED%95%A0%20%EC%88%98%20%EC%9E%88%EC%8A%B5%EB%8B%88%EB%8B%A4.%0A%20%20%20%20%2F%2F%20%EB%A7%8C%EC%95%BD%20%ED%83%80%EC%9E%85%EC%9D%84%20%EB%AA%85%EC%8B%9C%EC%A0%81%EC%9C%BC%EB%A1%9C%20%EC%A7%80%EC%A0%95%ED%95%98%EA%B3%A0%20%EC%8B%B6%EB%8B%A4%EB%A9%B4%20%EB%8B%A4%EC%9D%8C%EA%B3%BC%20%EA%B0%99%EC%9D%B4%20%EC%9E%91%EC%84%B1%ED%95%A9%EB%8B%88%EB%8B%A4.%0A%20%20%20%20let%20z%3A%20i64%20%3D%20100%3B%0A%0A%20%20%20%20%2F%2F%20%EB%B3%80%EC%88%98%EC%9D%98%20%EC%9D%B4%EB%A6%84%EC%9D%84%20%EC%97%AC%EB%9F%AC%20%EB%B2%88%20%EC%82%AC%EC%9A%A9%ED%95%98%EC%97%AC%20%EA%B0%92%EC%9D%84%20%ED%95%A0%EB%8B%B9%ED%95%A0%20%EC%88%98%20%EC%9E%88%EC%8A%B5%EB%8B%88%EB%8B%A4.%0A%20%20%20%20let%20mut%20count%20%3D%200%3B%0A%20%20%20%20count%20%3D%201%3B%0A%20%20%20%20count%20%3D%202%3B%0A%0A%20%20%20%20%2F%2F%20%EB%B3%80%EC%88%98%EC%9D%98%20%ED%83%80%EC%9E%85%EC%9D%84%20%EB%B3%80%EA%B2%BD%ED%95%98%EC%97%AC%20%EC%9E%AC%EC%82%AC%EC%9A%A9%ED%95%A0%20%EC%88%98%20%EC%9E%88%EC%8A%B5%EB%8B%88%EB%8B%A4.%0A%20%20%20%20let%20x%20%3D%20%22hello%22%3B%20%2F%2F%20x%EB%8A%94%20%EB%AC%B8%EC%9E%90%EC%97%B4%20%ED%83%80%EC%9E%85%EC%9E%85%EB%8B%88%EB%8B%A4.%0A%20%20%20%20let%20x%20%3D%205%3B%20%2F%2F%20x%EB%8A%94%20%EC%A0%95%EC%88%98%20%ED%83%80%EC%9E%85%EC%9C%BC%EB%A1%9C%20%EB%B3%80%EA%B2%BD%EB%90%A9%EB%8B%88%EB%8B%A4.%0A%0A%20%20%20%20%2F%2F%20%EB%B3%80%EC%88%98%EC%9D%98%20%EC%9D%B4%EB%A6%84%EC%9D%80%20snake_case%EB%A1%9C%20%EC%9E%91%EC%84%B1%ED%95%A9%EB%8B%88%EB%8B%A4.%0A%20%20%20%20let%20first_name%20%3D%20%22Choi%22%3B%0A%20%20%20%20let%20last_name%20%3D%20%22Blah%22%3B%0A%0A%20%20%20%20%2F%2F%20%EB%B3%80%EC%88%98%EC%9D%98%20%EA%B0%92%EC%9D%84%20%EC%B6%9C%EB%A0%A5%ED%95%A9%EB%8B%88%EB%8B%A4.%0A%20%20%20%20println!(%22x%20is%20%7B%7D%22%2C%20x)%3B%20%2F%2F%20%22x%20is%205%22%EA%B0%80%20%EC%B6%9C%EB%A0%A5%EB%90%A9%EB%8B%88%EB%8B%A4.%0A%7D%0A
  content_markdown: >
    Rust에서는 `let` 키워드를 사용하여 변수를 선언합니다.

    <div align="center">
    <p>
        <img src="https://user-images.githubusercontent.com/2356749/223641752-4b38e61f-82f4-450d-b778-526cb7ad618c.png">
    </p>
    </div>

    값을 할당할 때, Rust는 거의 대부분 변수의 타입을 추론할 수 있습니다.


    만약 Rust가 추론하지 못하면 변수의 선언 시 타입을 추가할 수 있습니다.


    변수의 이름을 여러 번 사용하여 값을 할당할 수 있습니다.


    이를 "shadowing"이라고 하며, 변수의 타입은 재할당될 때마다 변경됩니다.


    변수의 이름은 항상 `snake_case`로 작성합니다.

- title: 변수 업데이트
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&code=fn+main%28%29+%7B%0A++++let+mut+x+%3D+42%3B%0A++++println%21%28%22%7B%7D%22%2C+x%29%3B%0A++++x+%3D+13%3B%0A++++println%21%28%22%7B%7D%22%2C+x%29%3B%0A%0A++++let+y+%3D+23%3B%0A++++println%21%28%22%7B%7D%22%2C+y%29%3B%0A++++%2F%2F+y+%3D+9%3B++%2F%2F+%EC%97%90%EB%9F%AC%0A%7D%0A
  content_markdown: >
    Rust는 변수가 변경 가능한지 여부에 대해 많은 주의를 기울입니다.

    * **mutable (가변)** - 컴파일러는 해당 변수에 대해 `쓰거나 읽을 수` 있도록 허용합니다.

    * **immutable (불변)** - 컴파일러는 해당 변수에 대해서 `읽기만` 가능하도록 허용합니다.


    가변 값은 **mut** 키워드로 구분됩니다.

- title: 기본 타입
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20x%20%3D%2012%3B%20%2F%2F%20by%20default%20this%20is%20i32%0A%20%20%20%20let%20a%20%3D%2012u8%3B%0A%20%20%20%20let%20b%20%3D%204.3%3B%20%2F%2F%20by%20default%20this%20is%20f64%0A%20%20%20%20let%20c%20%3D%204.3f32%3B%0A%20%20%20%20let%20bv%20%3D%20true%3B%0A%20%20%20%20let%20t%20%3D%20(13%2C%20false)%3B%0A%20%20%20%20let%20sentence%20%3D%20%22hello%20world!%22%3B%0A%20%20%20%20println!(%0A%20%20%20%20%20%20%20%20%22%7B%7D%20%7B%7D%20%7B%7D%20%7B%7D%20%7B%7D%20%7B%7D%20%7B%7D%20%7B%7D%22%2C%0A%20%20%20%20%20%20%20%20x%2C%20a%2C%20b%2C%20c%2C%20bv%2C%20t.0%2C%20t.1%2C%20sentence%0A%20%20%20%20)%3B%0A%7D%0A
  content_markdown: >
    Rust는 다양한 익숙한 유형을 제공합니다:


    <div align="center">
    <p>
        <img src="https://user-images.githubusercontent.com/2356749/228573875-e7980e94-248c-4477-b522-79f9532bf0f1.png">
    </p>
    </div>


    * booleans - `bool`로 참/거짓 (1 byte)

    * unsigned integers (부호 없는 정수) - 음이 아닌 정수를 나타내는 `u8`, `u16`, `u32`, `u64`, `u128` (u8 = 1 byte, u128 = 16 bytes)

    * signed integers (부호 있는 정수) - 정수를 나타내는 `i8`, `i16`, `i32`, `i64`, `i128`

    * pointer sized integers - 메모리에서 색인과 항목의 크기를 나타내는 `usize`, `isize` (보통 4 or 8 bytes)

    * floating point - `f32`, `f64` (4, 8 bytes)

    * tuple - 고정된 값의 시퀀스를 스택에 전달하는 `(value, value, ...)`

    * arrays - 컴파일 시점에서 크기가 고정되어 있는 비슷한 요소의 집합으로 `[value, value, ...]` ([i32; 3] = 12 bytes)

    * slices - 런타임에 길이가 알려진 비슷한 요소의 집합

    * `str`(문자열 슬라이스) - 런타임에 길이가 알려진 텍스트


    숫자형은 숫자 끝에 유형을 명시하여 명시적으로 지정할 수 있습니다(예: `13u32`, `2u8`).


    다른 언어에서 사용하는 것보다 텍스트는 더 복잡할 수 있습니다.


    Rust가 시스템 프로그래밍 언어이기 때문에, 기존에 익숙하지 않은 메모리 문제에 대해서도 신경쓰고 있습니다.


    이에 대해서는 다음 페이지를 참고해주세요!
- title: 문자열
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&code=fn+main%28%29+%7B%0A++++let+my_literal%3A+%26%27static+str+%3D+%22%EC%95%88%EB%85%95%ED%95%98%EC%84%B8%EC%9A%94%21%22%3B%0A%0A++++let+full_name+%3D+%22%ED%99%8D%EA%B8%B8%EB%8F%99%22%3B%0A++++let+first_name%3A+%26str+%3D+%26full_name%5B..6%5D%3B+%2F%2F+%22%ED%99%8D%EA%B8%B8%22%EB%A7%8C+%EC%B0%B8%EC%A1%B0%2C+3+per+each+korean+char.%0A++++println%21%28%22%7B%7D%22%2C+first_name%29%3B%0A%0A++++let+mut+my_string+%3D+String%3A%3Afrom%28%22%EC%95%88%EB%85%95%ED%95%98%EC%84%B8%EC%9A%94%21%22%29%3B%0A++++my_string.push_str%28%22+%EB%A7%8C%EB%82%98%EC%84%9C+%EB%B0%98%EA%B0%80%EC%9B%8C%EC%9A%94%21%22%29%3B%0A++++println%21%28%22%7B%7D%22%2C+my_string%29%3B%0A%0A++++let+my_str+%3D+%22%EC%95%88%EB%85%95%ED%95%98%EC%84%B8%EC%9A%94%21%22%3B%0A++++let+my_string+%3D+my_str.to_owned%28%29%3B+%2F%2F+String+%ED%83%80%EC%9E%85%EC%9C%BC%EB%A1%9C+%EB%B3%80%EA%B2%BD%0A++++println%21%28%22%7B%3A%23%3F%7D%22%2C+my_string%29%3B%0A%0A++++let+my_number+%3D+42%3B%0A++++let+my_number_string+%3D+my_number.to_string%28%29%3B+%2F%2F+%2242%22%EB%9D%BC%EB%8A%94+String+%ED%83%80%EC%9E%85%EC%9C%BC%EB%A1%9C+%EB%B3%80%EA%B2%BD%0A++++println%21%28%22%7B%7D%22%2C+my_number_string%29%3B%0A%7D%0A
  content_markdown: >
    Rust에서 문자열을 다루는 데에는 주로 세 가지 타입이 사용됩니다.


    `str, &str, String`


    이 세 가지 타입의 차이와 예제, 그리고 to\_owned()와 to_string() 메소드의 차이에 대해 알아보겠습니다.


    ---


    `str`: 이 타입은 문자열 리터럴을 나타냅니다.


    보통 직접 사용하지 않고 &str 형태로 참조합니다. str 타입은 불변이며 크기가 고정되어 있습니다.


    %rust%
    // 예제 1

    let my_literal: &'static str = "안녕하세요!";

    // let a: str = "abc"; 불가능: str이 고정 크기가 아니라 런타임에 크기가 결정되기 때문

    // Sized, ?Sized 개념, 컴파일 시점에 크기가 결정되지 않는 타입은 직접 사용하는 것이 불가능
    %end%


    ---


    `&str`: 이 타입은 str의 참조이며 불변이며 문자열 슬라이스를 나타냅니다.


    &str을 사용하면, 메모리를 절약하면서 문자열의 일부분을 참조할 수 있습니다.


    &str은 실제 문자열 데이터를 저장하는 것이 아니라, 메모리의 문자열 데이터를 가리키는 참조입니다.


    이러한 방식을 사용함으로써, Rust는 안전성과 소유권을 보장할 수 있습니다.


    %rust%
    // 예제 2

    let full_name = "홍길동";

    let first_name: &str = &full_name[..6]; // "홍길"만 참조, 한글 3bytes, 알파벳 1byte
    %end%


    ---


    `String`: 이 타입은 가변하며 크기가 변경될 수 있는 문자열입니다.


    String은 `Heap`에 저장되며, 필요에 따라 크기를 늘이거나 줄일 수 있습니다.


    %rust%
    // 예제 3

    let mut my_string = String::from("안녕하세요!");

    my_string.push_str(" 만나서 반가워요!");
    %end%


    ---


    to\_owned()와 to\_string() 메소드의 차이점:


    to\_owned(): &str이나 다른 불변 타입의 참조에서 가변 타입으로 변경할 때 사용합니다.


    예를 들어, &str에서 String으로 변경할 때 사용할 수 있습니다.


    %rust%
    let my_str = "안녕하세요!";

    let my_string = my_str.to_owned(); // String 타입으로 변경
    %end%


    `to_string()`: ToString 트레잇(trait)을 구현하는 타입의 인스턴스를 문자열로 변환할 때 사용합니다.


    일반적으로 숫자 타입이나 사용자 정의 타입에서 String으로 변환할 때 사용합니다.


    %rust%
    let my_number = 42;

    let my_number_string = my_number.to_string(); // "42"라는 String 타입으로 변경
    %end%


    to\_owned()와 to_string()의 차이점은 사용 목적과 적용 대상이 다릅니다.


    to\_owned()는 불변 참조를 가변 타입으로 변경하는 데 사용되며,


    to\_string()은 ToString 트레잇을 구현하는 타입을 문자열로 변환하는 데 사용됩니다.


    문자열의 경우, to\_owned()와 to\_string()이 동일한 결과를 반환하지만, 다른 타입에 대해서는 다른 목적으로 사용됩니다.


    일반적으로 문자열 리터럴을 String으로 변환할 때는 to\_string()을 사용하고,


    &str에서 String으로 소유권을 이전할 때는 to\_owned()를 사용하는 것이 일반적인 관례입니다.


    즉, 문자열의 경우에는 두 메소드 모두 String으로의 변환을 수행하지만,


    다른 타입들의 경우에는 to\_string()이 문자열 변환을 처리하고, to\_owned()는 다른 목적으로 사용됩니다.


    참고: [@Rust 공식 문서](https://rinthel.github.io/rust-lang-book-ko/ch08-02-strings.html)
- title: Basic Type Conversion
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20a%20%3D%2013u8%3B%0A%20%20%20%20let%20b%20%3D%207u32%3B%0A%20%20%20%20let%20c%20%3D%20a%20as%20u32%20%2B%20b%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20c)%3B%0A%0A%20%20%20%20let%20t%20%3D%20true%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20t%20as%20u8)%3B%0A%7D%0A
  content_markdown: >
    Rust는 숫자 변수 타입에 대해 알고 있어야하며, `u8`를 `u32`로 쉽게 사용할 수 없습니다.


    다행히 Rust는 **as** 키워드를 사용하여 숫자형을 쉽게 변환할 수 있습니다.


    또는 `parse`를 자주 사용합니다.

    %rust%
    let my_string = "42";

    let my_integer = my_string.parse::&lt;i32>().unwrap();

    // double colon op, ::&lt;i32> syntax tells the compiler to parse the string as an i32 type

    %end%
- title: Constants
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=const%20PI%3A%20f32%20%3D%203.14159%3B%0A%0Afn%20main()%20%7B%0A%20%20%20%20println!(%0A%20%20%20%20%20%20%20%20%22To%20make%20an%20apple%20%7B%7D%20from%20scratch%2C%20you%20must%20first%20create%20a%20universe.%22%2C%0A%20%20%20%20%20%20%20%20PI%0A%20%20%20%20)%3B%0A%7D%0A
  content_markdown: >
    상수는 변수와 달리 곳곳에서 사용되는 공통된 값을 효율적으로 지정하는 데 사용됩니다.


    변수와 같은 곳에서 값이 복사되는 대신, 상수는 컴파일 시간에 사용되는 위치에서 직접 값을 대체합니다.


    변수와 달리, 상수는 항상 명시적인 유형을 가져야 합니다.


    상수 이름은 항상 `SCREAMING_SNAKE_CASE`로 지정됩니다.
- title: if, while, for
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&code=%23%5Ballow%28unused_assignments%29%5D%0A%0Afn+main%28%29+%7B%0A++++%2F%2F+%EB%A0%88%EC%9D%B4%EB%B8%94%EC%9D%84+%EC%82%AC%EC%9A%A9%ED%95%9C+while+%EB%AC%B8+%EC%98%88%EC%A0%9C%0A++++let+mut+x+%3D+0%3B%0A++++let+mut+y+%3D+0%3B%0A%0A++++%27outer_while%3A+while+x+%3C+5+%7B%0A++++++++y+%3D+0%3B%0A%0A++++++++while+y+%3C+5+%7B%0A++++++++++++if+x+*+y+%3E+10+%7B%0A++++++++++++++++println%21%28%22%EC%A1%B0%EA%B1%B4+%EB%A7%8C%EC%A1%B1%3A+x%3D%7B%7D%2C+y%3D%7B%7D%22%2C+x%2C+y%29%3B%0A++++++++++++++++break+%27outer_while%3B%0A++++++++++++%7D%0A++++++++++++y+%2B%3D+1%3B%0A++++++++%7D%0A%0A++++++++x+%2B%3D+1%3B%0A++++%7D%0A%0A++++%2F%2F+%EB%A0%88%EC%9D%B4%EB%B8%94%EC%9D%84+%EC%82%AC%EC%9A%A9%ED%95%9C+for+%EB%AC%B8+%EC%98%88%EC%A0%9C%0A++++%27outer_for%3A+for+x+in+0..5+%7B%0A++++++++for+y+in+0..5+%7B%0A++++++++++++if+x+*+y+%3E+10+%7B%0A++++++++++++++++println%21%28%22%EC%A1%B0%EA%B1%B4+%EB%A7%8C%EC%A1%B1%3A+x%3D%7B%7D%2C+y%3D%7B%7D%22%2C+x%2C+y%29%3B%0A++++++++++++++++break+%27outer_for%3B%0A++++++++++++%7D%0A++++++++%7D%0A++++%7D%0A%0A++++%2F%2F+%EB%A0%88%EC%9D%B4%EB%B8%94%EC%9D%84+%EC%82%AC%EC%9A%A9%ED%95%9C+loop+%EB%AC%B8+%EC%98%88%EC%A0%9C%0A++++let+mut+x+%3D+0%3B%0A++++let+mut+y+%3D+0%3B%0A%0A++++%27outer_loop%3A+loop+%7B%0A++++++++y+%3D+0%3B%0A%0A++++++++loop+%7B%0A++++++++++++if+x+*+y+%3E+10+%7B%0A++++++++++++++++println%21%28%22%EC%A1%B0%EA%B1%B4+%EB%A7%8C%EC%A1%B1%3A+x%3D%7B%7D%2C+y%3D%7B%7D%22%2C+x%2C+y%29%3B%0A++++++++++++++++break+%27outer_loop%3B%0A++++++++++++%7D%0A%0A++++++++++++y+%2B%3D+1%3B%0A++++++++++++if+y+%3E%3D+5+%7B%0A++++++++++++++++break%3B%0A++++++++++++%7D%0A++++++++%7D%0A%0A++++++++x+%2B%3D+1%3B%0A++++++++if+x+%3E%3D+5+%7B%0A++++++++++++break%3B%0A++++++++%7D%0A++++%7D%0A%7D%0A
  content_markdown: >
    **반복문과 조건문**


    조건문과 반복문은 프로그램의 흐름을 제어하는 데 사용되는 기본적인 구조입니다.


    Rust에서는 if, while, for 문을 사용하여 조건문과 반복문을 작성할 수 있습니다.


    ## if 문


    if 문은 주어진 조건이 참인 경우에만 코드 블록을 실행합니다.


    %rust%
    if 조건 {
        // 조건이 참일 때 실행할 코드
    }
    %end%


    ## while 문


    while 문은 주어진 조건이 참인 동안 코드 블록을 계속 반복해서 실행합니다.

    %rust%
    while 조건 {
        // 조건이 참인 동안 반복할 코드
    }
    %end%


    ## for 문


    for 문은 반복 가능한 객체(예: 범위, 벡터 등)를 순회하며 코드 블록을 실행합니다.


    %rust%
    // Range를 사용한 for 문

    for 변수 in 시작..끝_미포함 { // range(시작, 끝)
        // 코드 블록
    }


    for 변수 in 시작..=끝_포함 { // range(시작, 끝 + 1)
        // 코드 블록
    }
    %end%


    %rust%
    // Loop 키워드를 사용한 무한 반복

    loop {
        // 무한 반복할 코드
        // 'break'를 사용해 반복을 종료할 수 있음
    }
    %end%



    ## 레이블(label)


    Rust에서 while, for, loop 문에서 이름을 지정하고 break할 수 있습니다.


    레이블은 `이름:` 형식으로 작성하며, break할 때 `break 이름;`을 사용합니다.


    이렇게 하면 중첩된 반복문에서 특정 반복문을 종료할 수 있습니다.


    %rust%
    // 2 이상의 소수를 찾아 출력하는 프로그램

    fn main() {
        let mut number = 2;

        'search: loop {
            let mut is_prime = true;

            'check_prime: for i in 2..number {
                if number % i == 0 {
                    is_prime = false;
                    break 'check_prime;
                }
            }

            if is_prime {
                println!("소수 발견: {}", number);
            }

            number += 1;
            if number > 20 {
                break 'search;
            }
        }
    }
    %end%


    위 예제 동작 순서

    - `number` 변수를 2로 초기화합니다.

    - `search` 라는 이름의 loop 문에서 소수를 찾기 시작합니다.

    - `check_prime` 이라는 이름의 for 문에서 2부터 `number - 1` 까지 나누어 떨어지는지 확인합니다.

    - 만약 나누어 떨어진다면, `is_prime` 변수를 false로 설정하고 `check_prime` 레이블을 사용하여 for 문을 빠져나옵니다.

    - `is_prime` 이 true인 경우, 소수를 발견했으므로 해당 숫자를 출력합니다.

    - `number` 를 1 증가시키고, `number` 가 20보다 크면 `search` 레이블을 사용하여 loop 문을 빠져나옵니다.
- title: Scope
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn+main%28%29+%7B%0D%0A++++let+mut+s+%3D+String%3A%3Afrom%28%22hello%22%29%3B%0D%0A%0D%0A++++let+r1%3B%0D%0A++++let+r2%3B%0D%0A++++let+r3%3B%0D%0A%0D%0A++++%7B%0D%0A++++++++r1+%3D+%26s%3B%0D%0A++++++++r2+%3D+%26s%3B%0D%0A++++++++println%21%28%22%EC%95%88%EC%AA%BD+inner+%EB%B2%94%EC%9C%84%2C+r1%3A+%7B%7D%2C+r2%3A+%7B%7D%22%2C+r1%2C+r2%29%3B%0D%0A++++++++%2F%2F+r1%EA%B3%BC+r2%EC%9D%98+%EB%B2%94%EC%9C%84%EB%A5%BC+%EC%97%AC%EA%B8%B0%EC%97%90%EC%84%9C+%EC%A2%85%EB%A3%8C%EC%8B%9C%ED%82%A4%EA%B8%B0+%EC%9C%84%ED%95%B4+%EC%A4%91%EA%B4%84%ED%98%B8%EB%A5%BC+%EC%B6%94%EA%B0%80%ED%95%A9%EB%8B%88%EB%8B%A4.%0D%0A++++%7D%0D%0A%0D%0A++++%7B%0D%0A++++++++r3+%3D+%26mut+s%3B%0D%0A++++++++println%21%28%22%EC%95%88%EC%AA%BD+%EB%8B%A4%EB%A5%B8+inner+%EB%B2%94%EC%9C%84%2C+r3%3A+%7B%7D%22%2C+r3%29%3B%0D%0A++++%7D%0D%0A%0D%0A++++%2F%2F+%EC%9D%B4%EC%A0%9C+r1%EA%B3%BC+r2%EB%8A%94+%EB%8D%94+%EC%9D%B4%EC%83%81+%EC%82%AC%EC%9A%A9%EB%90%98%EC%A7%80+%EC%95%8A%EC%9C%BC%EB%AF%80%EB%A1%9C+%EC%B6%9C%EB%A0%A5%EC%97%90%EC%84%9C+%EC%A0%9C%EC%99%B8%ED%95%A9%EB%8B%88%EB%8B%A4.%0D%0A++++println%21%28%22%EB%B0%94%EA%B9%A5+%EC%AA%BD+inner+%EB%B2%94%EC%9C%84%2C+r3%3A+%7B%7D%22%2C+r3%29%3B%0D%0A%7D%0D%0A
  content_markdown: >
    *범위*


    범위는 프로그램 내에서 변수가 유효한 영역을 정의합니다.


    %rust%
    fn main() {
        let x = 10;

        {
            let y = 20;
            println!("Inside the inner scope, x: {}, y: {}", x, y);
        }

        println!("Outside the inner scope, x: {}", x);
        // println!("Outside the inner scope, y: {}", y); // This will cause a compile error
    }
    %end%


    우측 예제에서는 r1, r2, r3라는 세 개의 참조가 선언되어 있으며, 각각 두 개의 다른 범위에서 초기화됩니다.


    첫 번째 범위에서 r1과 r2는 s에 대한 불변 참조로 초기화됩니다.


    이 범위가 종료되면, r1과 r2에 대한 참조는 더 이상 유효하지 않습니다.


    두 번째 범위에서는 r3가 s에 대한 변경 가능한 참조로 초기화됩니다.


    이렇게 하면 첫 번째 범위에서의 불변 참조와 겹치지 않으므로 빌림 규칙에 위배되지 않습니다.


    마지막으로 모든 범위가 종료된 후에는 각 참조가 각각 다른 범위에서 초기화되었기 때문에 r1, r2, r3를 함께 출력할 수 있습니다.
- title: Arrays
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20nums%3A%20%5Bi32%3B%203%5D%20%3D%20%5B1%2C%202%2C%203%5D%3B%0A%20%20%20%20println!(%22%7B%3A%3F%7D%22%2C%20nums)%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20nums%5B1%5D)%3B%0A%7D%0A
  content_markdown: >
    *배열*은 동일한 유형의 데이터 요소들의 **고정된 길이 집합**입니다.


    *배열*의 데이터 유형은 `[T;N]` 입니다.

    (T는 요소의 유형이고, N은 컴파일 시간에 알려진 고정 길이)


    개별 요소는 `[x]` 연산자를 사용하여 가져올 수 있습니다.

    여기서 x는 원하는 요소의 *usize* 인덱스(0부터 시작)입니다.


    가변 길이의 컬렉션, 즉 가변 배열은 나중에 **Vectors**에 대한 챕터에서 소개됩니다.
- title: Functions
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20add(x%3A%20i32%2C%20y%3A%20i32)%20-%3E%20i32%20%7B%0A%20%20%20%20return%20x%20%2B%20y%3B%0A%7D%0A%0Afn%20subtract(x%3A%20i32%2C%20y%3A%20i32)%20-%3E%20i32%20%7B%0A%20%20%20%20x%20-%20y%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20println!(%2242%20%2B%2013%20%3D%20%7B%7D%22%2C%20add(42%2C%2013))%3B%0A%20%20%20%20println!(%2242%20-%2013%20%3D%20%7B%7D%22%2C%20subtract(42%2C%2013))%3B%0A%7D%0A
  content_markdown: >
    함수는 매개변수 (parameter)가 없거나 여러 개일 수 있습니다.


    이 예제에서 *add* 함수는 `i32`(32비트 길이의 부호 있는 정수)형 두 개의 인수를 취합니다.


    *subtract* 함수에서와 같이 표현식만 반환하려면 `return` 키워드와 세미콜론을 삭제할 수 있습니다.


    함수 이름은 항상 `snake_case`로 지정됩니다.


    힌트: 함수를 정의하는 경우, 해당 함수가 수신하는 데이터를 매개변수 (parameter)라고합니다.

    그 함수를 호출하고 데이터를 전달하면 인수(argument)라고합니다.


    ```python

    # 파이썬으로 보면

    def add(x: int, y: int) -> int:
        return x + y

    def subtract(x: int, y: int) -> int:
        return x - y

    def main():
        print(f"42 + 13 = {add(42, 13)}")
        print(f"42 - 13 = {subtract(42, 13)}")


    if __name__ == "__main__":
        main()
    ```
- title: Multiple Return Values
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20swap(x%3A%20i32%2C%20y%3A%20i32)%20-%3E%20(i32%2C%20i32)%20%7B%0A%20%20%20%20return%20(y%2C%20x)%3B%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20return%20a%20tuple%20of%20return%20values%0A%20%20%20%20let%20result%20%3D%20swap(123%2C%20321)%3B%0A%20%20%20%20println!(%22%7B%7D%20%7B%7D%22%2C%20result.0%2C%20result.1)%3B%0A%0A%20%20%20%20%2F%2F%20destructure%20the%20tuple%20into%20two%20variables%20names%0A%20%20%20%20let%20(a%2C%20b)%20%3D%20swap(result.0%2C%20result.1)%3B%0A%20%20%20%20println!(%22%7B%7D%20%7B%7D%22%2C%20a%2C%20b)%3B%0A%7D%0A
  content_markdown: >
    함수는 값의 **튜플**을 반환하여 여러 값을 반환할 수 있습니다.


    튜플 요소는 인덱스 번호를 사용하여 참조할 수 있습니다.


    Rust는 여러 형식의 destructuring을 지원합니다.

    우리는 더 많은 형태로 볼 것이며, 이를 통해 데이터 구조의 하위 요소를 직관적으로 추출할 수 있습니다.
- title: match
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&code=%2F%2F+%EC%97%B4%EA%B1%B0%ED%98%95+%EC%A0%95%EC%9D%98%3A+%EC%97%AC%EB%9F%AC+%EB%8F%84%ED%98%95%EC%9D%84+%EB%82%98%ED%83%80%EB%83%85%EB%8B%88%EB%8B%A4.%0Aenum+Shape+%7B%0A++++Circle+%7B+radius%3A+f64+%7D%2C%0A++++Square+%7B+side%3A+f64+%7D%2C%0A++++Rectangle+%7B+width%3A+f64%2C+height%3A+f64+%7D%2C%0A%7D%0A%0A%2F%2F+%EB%8F%84%ED%98%95%EC%9D%98+%EB%84%93%EC%9D%B4%EB%A5%BC+%EA%B3%84%EC%82%B0%ED%95%98%EB%8A%94+%ED%95%A8%EC%88%98%0Afn+calculate_area%28shape%3A+Shape%29+-%3E+f64+%7B%0A++++%2F%2F+%ED%8C%A8%ED%84%B4+%EB%A7%A4%EC%B9%AD%EC%9D%84+%EC%82%AC%EC%9A%A9%ED%95%98%EC%97%AC+%EB%8F%84%ED%98%95%EC%9D%98+%EC%A2%85%EB%A5%98%EC%97%90+%EB%94%B0%EB%9D%BC+%EA%B3%84%EC%82%B0+%EB%B0%A9%EC%8B%9D%EC%9D%84+%EC%84%A0%ED%83%9D%ED%95%A9%EB%8B%88%EB%8B%A4.%0A++++match+shape+%7B%0A++++++++Shape%3A%3ACircle+%7B+radius+%7D+%3D%3E+std%3A%3Af64%3A%3Aconsts%3A%3API+*+radius+*+radius%2C+%2F%2F+%EC%9B%90%EC%9D%98+%EB%84%93%EC%9D%B4+%EA%B3%84%EC%82%B0%0A++++++++Shape%3A%3ASquare+%7B+side+%7D+%3D%3E+side+*+side%2C++++++++++++++++++++++++++++++%2F%2F+%EC%A0%95%EC%82%AC%EA%B0%81%ED%98%95%EC%9D%98+%EB%84%93%EC%9D%B4+%EA%B3%84%EC%82%B0%0A++++++++Shape%3A%3ARectangle+%7B+width%2C+height+%7D+%3D%3E+width+*+height%2C+++++++++++++++%2F%2F+%EC%A7%81%EC%82%AC%EA%B0%81%ED%98%95%EC%9D%98+%EB%84%93%EC%9D%B4+%EA%B3%84%EC%82%B0%0A++++%7D%0A%7D%0A%0Afn+main%28%29+%7B%0A++++%2F%2F+%EC%97%AC%EB%9F%AC+%EB%8F%84%ED%98%95+%EC%83%9D%EC%84%B1%0A++++let+circle+%3D+Shape%3A%3ACircle+%7B+radius%3A+5.0+%7D%3B%0A++++let+square+%3D+Shape%3A%3ASquare+%7B+side%3A+4.0+%7D%3B%0A++++let+rectangle+%3D+Shape%3A%3ARectangle+%7B%0A++++++++width%3A+6.0%2C%0A++++++++height%3A+3.0%2C%0A++++%7D%3B%0A%0A++++%2F%2F+%ED%8C%A8%ED%84%B4+%EB%A7%A4%EC%B9%AD%EC%9D%84+%EC%82%AC%EC%9A%A9%ED%95%98%EC%97%AC+%EA%B0%81+%EB%8F%84%ED%98%95%EC%9D%98+%EB%84%93%EC%9D%B4%EB%A5%BC+%EA%B3%84%EC%82%B0%ED%95%98%EA%B3%A0+%EC%B6%9C%EB%A0%A5%ED%95%A9%EB%8B%88%EB%8B%A4.%0A++++let+circle_area+%3D+calculate_area%28circle%29%3B%0A++++let+square_area+%3D+calculate_area%28square%29%3B%0A++++let+rectangle_area+%3D+calculate_area%28rectangle%29%3B%0A%0A++++println%21%28%22%EC%9B%90%EC%9D%98+%EB%84%93%EC%9D%B4%3A+%7B%7D%22%2C+circle_area%29%3B%0A++++println%21%28%22%EC%A0%95%EC%82%AC%EA%B0%81%ED%98%95%EC%9D%98+%EB%84%93%EC%9D%B4%3A+%7B%7D%22%2C+square_area%29%3B%0A++++println%21%28%22%EC%A7%81%EC%82%AC%EA%B0%81%ED%98%95%EC%9D%98+%EB%84%93%EC%9D%B4%3A+%7B%7D%22%2C+rectangle_area%29%3B%0A%7D%0A
  content_markdown: >
    Rust에서 match 키워드는 패턴 매칭을 위해 사용하고


    값과 일련의 패턴을 비교할 수 있게 해줍니다.


    그리고 첫 번째 일치하는 패턴에 해당하는 코드 블록을 실행합니다.


    %rust%
    fn main() {
        let number = 42;

        match number {
            0 => println!("숫자는 영입니다"),
            1 => println!("숫자는 일입니다"),
            42 => println!("인생, 우주, 그리고 모든 것에 대한 답"),
            _ => println!("다른 숫자입니다"),
        }
    }
    %end%

    여기서는 number 변수의 값을 여러 패턴과 비교합니다.


    `_` 패턴은 이전 패턴에서 명시적으로 다루지 않은 모든 값을 매치하는 `catch-all` 패턴입니다.


    %rust%
    fn classify_age(age: u8) {
        match age {
            0..=12 => println!("어린이"),
            13..=19 => println!("청소년"),
            20..=64 => println!("성인"),
            _ => println!("노인"),
        }
    }

    fn main() {
        let age = 65;
        classify_age(age);
        let age = 30;
        classify_age(age);
    }
    %end%


    이 예제에서는 match 표현식을 사용하여 나이를 그룹으로 분류하고,


    나이 변수와 매치하기 위해 범위를 패턴으로 사용합니다.
- title: Struct and Enum
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&code=%2F%2F+%ED%8A%B9%EC%84%B1+%28Trait%29+%EC%A0%95%EC%9D%98%0D%0Atrait+Greet+%7B%0D%0A++++fn+greet%28%26self%29+-%3E+String%3B%0D%0A%7D%0D%0A%0D%0A%2F%2F+%EA%B5%AC%EC%A1%B0%EC%B2%B4+%28Struct%29+%EC%A0%95%EC%9D%98%0D%0Astruct+Person+%7B%0D%0A++++name%3A+String%2C%0D%0A%7D%0D%0A%0D%0A%2F%2F+%EA%B5%AC%EC%A1%B0%EC%B2%B4%EC%97%90+%EB%8C%80%ED%95%9C+%ED%8A%B9%EC%84%B1+%EA%B5%AC%ED%98%84%0D%0Aimpl+Greet+for+Person+%7B%0D%0A++++fn+greet%28%26self%29+-%3E+String+%7B%0D%0A++++++++format%21%28%22%EC%95%88%EB%85%95%ED%95%98%EC%84%B8%EC%9A%94%2C+%7B%7D%EB%8B%98%21%22%2C+self.name%29%0D%0A++++%7D%0D%0A%7D%0D%0A%0D%0A%2F%2F+%EC%97%B4%EA%B1%B0%ED%98%95+%28Enum%29+%EC%A0%95%EC%9D%98%0D%0Aenum+Animal+%7B%0D%0A++++Dog%2C%0D%0A++++Cat%2C%0D%0A%7D%0D%0A%0D%0A%2F%2F+%EC%97%B4%EA%B1%B0%ED%98%95%EC%97%90+%EB%8C%80%ED%95%9C+%ED%8A%B9%EC%84%B1+%EA%B5%AC%ED%98%84%0D%0Aimpl+Greet+for+Animal+%7B%0D%0A++++fn+greet%28%26self%29+-%3E+String+%7B%0D%0A++++++++match+self+%7B%0D%0A++++++++++++Animal%3A%3ADog+%3D%3E+String%3A%3Afrom%28%22%EB%A9%8D%EB%A9%8D%21%22%29%2C%0D%0A++++++++++++Animal%3A%3ACat+%3D%3E+String%3A%3Afrom%28%22%EC%95%BC%EC%98%B9%7E%22%29%2C%0D%0A++++++++%7D%0D%0A++++%7D%0D%0A%7D%0D%0A%0D%0Afn+main%28%29+%7B%0D%0A++++let+person+%3D+Person+%7B%0D%0A++++++++name%3A+String%3A%3Afrom%28%22%EA%B9%80%EC%95%84%EC%A3%BC%22%29%2C%0D%0A++++%7D%3B%0D%0A++++let+dog+%3D+Animal%3A%3ADog%3B%0D%0A%0D%0A++++%2F%2F+%EA%B5%AC%EC%A1%B0%EC%B2%B4%EC%99%80+%EC%97%B4%EA%B1%B0%ED%98%95+%EC%9D%B8%EC%8A%A4%ED%84%B4%EC%8A%A4%EC%97%90+greet+%EB%A9%94%EC%84%9C%EB%93%9C+%EC%82%AC%EC%9A%A9%0D%0A++++println%21%28%22%7B%7D%22%2C+person.greet%28%29%29%3B%0D%0A++++println%21%28%22%7B%7D%22%2C+dog.greet%28%29%29%3B%0D%0A%7D%0D%0A
  content_markdown: >
    **구조체 (Struct)**


    구조체는 struct 키워드를 사용하여 정의하며, 이름과 중괄호로 묶인 명명된 필드 집합이 뒤따릅니다.


    다음은 Person 구조체의 예입니다:

    %rust%
    struct Person {
      name: String,
      age: u8,
    }
    %end%

    구조체의 인스턴스를 생성하려면, 구조체 이름 뒤에 중괄호를 사용하고 필드에 값을 할당합니다.

    예를 들면:

    %rust%
    let person = Person { name: String::from("Alice"), age: 30 };
    %end%

    ---

    **열거형 (Enum)**


    열거형(enum, "enumeration"의 줄임말)은 고정된 명명된 값 집합인 "변종(variants)"을 가진 타입을 나타냅니다.


    열거형을 정의하려면, enum 키워드를 사용하고 이름과 중괄호로 묶인 명명된 변종 집합이 뒤따릅니다.


    다음은 Status 열거형의 예입니다:

    %rust%
    enum Status {
      Active,
      Inactive,
      Pending,
    }
    %end%


    열거형의 인스턴스를 생성하려면, 열거형 이름 뒤에 두 개의 콜론(`::`)과 변종 이름을 사용합니다.


    예를 들면:

    %rust%
    let status = Status::Active;
    %end%

    열거형 변종에 따라 다른 작업을 수행하려면 match 표현식을 사용할 수 있습니다:

    %rust%
    let user_status = Status::Active;
    %end%

    열거형을 다루려면, 종종 match 표현식을 사용하며, 이를 통해 열거형 변종에 따라 다른 작업을 수행할 수 있습니다:

    %rust%
    fn print_status_message(status: Status) {
        match status {
            Status::Active => println!("사용자가 활성 상태입니다."),
            Status::Inactive => println!("사용자가 비활성 상태입니다."),
            Status::Pending => println!("사용자가 보류 중입니다."),
        }
    }

    fn main() {
        let user_status = Status::Active;
        print_status_message(user_status);
    }
    %end%

    ---

    **Tuple Struct, Enum**


    주로 간결한 표현, 타입 안전성 및 논리적 구조를 위해 사용됩니다.


    - 튜플 구조체 (Tuple Struct): 튜플 구조체는 필드에 이름이 없는 구조체로, 간단한 데이터 구조를 표현할 때 유용합니다. 튜플 구조체를 사용하면, 구조체의 의미를 명확하게 나타낼 수 있으며, 일반 튜플보다 더 강력한 타입 안전성을 제공합니다. 예를 들어, 두 개의 float 값을 나타내는 Point2D와 Vector2D를 구별하기 위해 튜플 구조체를 사용할 수 있습니다. 이렇게 하면 코드의 가독성과 정확성이 향상됩니다.

    - 열거형 (Enum): 열거형은 서로 관련된 값의 집합을 표현하기 위해 사용됩니다. 열거형은 여러 변종(variants)을 가질 수 있으며, 각 변종은 고유한 타입입니다. 열거형은 논리적으로 관련된 여러 값을 그룹화하여 코드의 명확성과 구조를 개선하는 데 도움이 됩니다. 또한 열거형은 패턴 매칭을 사용하여 값에 따라 다양한 작업을 수행할 수 있어, 런타임에 오류가 발생하는 가능성이 줄어듭니다.

    - 튜플 열거형 변종 (Tuple Enum Variants): 튜플 열거형 변종은 열거형의 각 변종에 데이터를 연관시키는 데 사용됩니다. 튜플 열거형 변종은 각 변종에 서로 다른 타입과 수의 값을 저장할 수 있습니다. 이러한 변종은 열거형의 다양한 경우를 명확하게 구분하고, 관련 데이터를 함께 저장하여 논리적 구조를 제공하는 데 유용합니다. 패턴 매칭을 사용하면 튜플 열거형 변종의 값을 안전하게 추출하고, 해당 값에 따라 다양한 작업을 수행할 수 있습니다.

    %rust%
    // 튜플 구조체 (Tuple Struct)

    struct Point3D(f32, f32, f32);


    // 열거형에 튜플 변종 (Tuple Enum Variant) 포함

    enum Shape {
        Circle(f32),
        Rectangle(f32, f32),
    }


    fn main() {
        let point = Point3D(1.0, 2.0, 3.0);
        let circle = Shape::Circle(5.0);
        let rectangle = Shape::Rectangle(4.0, 6.0);

        // 튜플 구조체의 값에 접근
        println!("x 좌표: {}", point.0);
        println!("y 좌표: {}", point.1);
        println!("z 좌표: {}", point.2);

        // 튜플 열거형 변종의 값에 접근
        match circle {
            Shape::Circle(radius) => println!("원의 반지름: {}", radius),
            _ => (),
        }
    }
    %end%

    ---

    **Nested**

    중첩된 Struct과 Enum을 만들고 싶다면?

    %rust%
    // 중첩된 구조체 (Nested Struct)

    struct Address {
        street: String,
        city: String,
    }


    struct Person {
        name: String,
        address: Address,
    }

    // 중첩된 열거형 (Nested Enum)

    enum Animal {
        Mammal {
            species: String,
            is_domestic: bool,
        },
        Reptile {
            species: String,
            is_poisonous: bool,
        },
    }


    fn main() {
        let person = Person {
            name: String::from("지훈"),
            address: Address {
                street: String::from("서울로"),
                city: String::from("서울"),
            },
        };
        let dog = Animal::Mammal {
            species: String::from("개"),
            is_domestic: true,
        };
    }
    %end%

- title: Returning Nothing
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20make_nothing()%20-%3E%20()%20%7B%0A%20%20%20%20return%20()%3B%0A%7D%0A%0A%2F%2F%20the%20return%20type%20is%20implied%20as%20()%0Afn%20make_nothing2()%20%7B%0A%20%20%20%20%2F%2F%20this%20function%20will%20return%20()%20if%20nothing%20is%20specified%20to%20return%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20a%20%3D%20make_nothing()%3B%0A%20%20%20%20let%20b%20%3D%20make_nothing2()%3B%0A%0A%20%20%20%20%2F%2F%20Printing%20a%20debug%20string%20for%20a%20and%20b%0A%20%20%20%20%2F%2F%20Because%20it's%20hard%20to%20print%20nothingness%0A%20%20%20%20println!(%22The%20value%20of%20a%3A%20%7B%3A%3F%7D%22%2C%20a)%3B%0A%20%20%20%20println!(%22The%20value%20of%20b%3A%20%7B%3A%3F%7D%22%2C%20b)%3B%0A%7D%0A
  content_markdown: >
    함수에 대해 반환 유형이 지정되어 있지 않으면, *unit*이라고도 하는 빈 튜플을 반환합니다.


    빈 튜플은 `()`로 나타낼 수 있습니다.


    `()`을 사용하는 것은 드문 경우이지만 충분히 자주 출현하기 때문에 무슨 일이 일어나는지 알아둘 가치가 있습니다.
- title: Error handling
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&code=use+std%3A%3Afmt%3B%0Ause+std%3A%3Astr%3A%3AFromStr%3B%0A%0A%23%5Bderive%28Debug%29%5D%0Aenum+ParseIntegerError+%7B%0A++++InvalidNumber%28String%29%2C%0A++++ParseIntError%28std%3A%3Anum%3A%3AParseIntError%29%2C%0A%7D%0A%0Aimpl+fmt%3A%3ADisplay+for+ParseIntegerError+%7B%0A++++fn+fmt%28%26self%2C+f%3A+%26mut+fmt%3A%3AFormatter%29+-%3E+fmt%3A%3AResult+%7B%0A++++++++match+self+%7B%0A++++++++++++ParseIntegerError%3A%3AInvalidNumber%28ref+s%29+%3D%3E+write%21%28f%2C+%22Invalid+number%3A+%7B%7D%22%2C+s%29%2C%0A++++++++++++ParseIntegerError%3A%3AParseIntError%28ref+e%29+%3D%3E+e.fmt%28f%29%2C%0A++++++++%7D%0A++++%7D%0A%7D%0A%0Aimpl+std%3A%3Aerror%3A%3AError+for+ParseIntegerError+%7B%7D%0A%0Afn+parse_integer%28input%3A+%26str%29+-%3E+Result%3Ci32%2C+ParseIntegerError%3E+%7B%0A++++if+input.is_empty%28%29+%7B%0A++++++++return+Err%28ParseIntegerError%3A%3AInvalidNumber%28input.to_owned%28%29%29%29%3B%0A++++%7D%0A%0A++++let+value+%3D+i32%3A%3Afrom_str%28input%29.map_err%28ParseIntegerError%3A%3AParseIntError%29%3F%3B%0A++++Ok%28value%29%0A%7D%0A%0Afn+main%28%29+%7B%0A++++let+inputs+%3D+%5B%2242%22%2C+%22abc%22%2C+%22%22%5D%3B%0A++++for+input+in+%26inputs+%7B%0A++++++++let+parsed+%3D+parse_integer%28input%29%3B%0A%0A++++++++match+parsed+%7B%0A++++++++++++Ok%28value%29+%3D%3E+println%21%28%22The+integer+value+of+%27%7B%7D%27+is%3A+%7B%7D%22%2C+input%2C+value%29%2C%0A++++++++++++Err%28error%29+%3D%3E+println%21%28%22Error+parsing+%27%7B%7D%27%3A+%7B%7D%22%2C+input%2C+error%29%2C%0A++++++++%7D%0A++++%7D%0A%7D%0A
  content_markdown: >
    오류 핸들링은 Rust의 핵심 개념 중 하나로, 다양한 오류 상황을 효과적으로 처리할 수 있는 기능을 제공합니다.


    이 튜토리얼에서는 Rust에서의 오류 핸들링 기본 사항을 다룰 것입니다.


    이를 위해 Result 열거형(enum)과 match 문을 사용하여 오류를 처리하는 방법을 알아봅시다.


    **Result 열거형**

    Rust에서는 결과를 나타내기 위해 Result 열거형을 사용합니다.

    이는 다음과 같은 두 가지 값 중 하나를 갖습니다.
        - Ok(T): 연산이 성공적으로 수행되었을 때 반환되는 값 T.
        - Err(E): 연산이 실패했을 때 반환되는 오류 값 E.


    예를 들어, 정수를 문자열로 변환하는 간단한 함수를 작성해 봅시다.


    이 함수는 문자열을 입력으로 받아 정수로 변환하려고 시도하고, 변환에 성공하면 Ok 값을 반환합니다.


    만약 변환에 실패하면, Err 값을 반환합니다.


    %rust%
    fn parse_integer(input: &str) -> Result<i32, String> {
        match input.parse::&lt;i32>() {
            Ok(value) => Ok(value),
            Err(_) => Err(format!("'{}' is not a valid integer.", input)),
        }
    }
    %end%


    **match 문을 사용한 오류 처리**


    오류 처리를 위해 match 문을 사용하여 Result 열거형에 따른 처리를 구현할 수 있습니다. 


    예를 들어, 다음 코드는 parse_integer 함수의 결과를 처리합니다.


    %rust%
    fn main() {
        let input = "42";
        let parsed = parse_integer(input);

        match parsed {
            Ok(value) => println!("The integer value is: {}", value),
            Err(error) => println!("Error: {}", error),
        }
    }
    %end%


    이 코드는 parse_integer 함수를 호출하여 결과를 가져옵니다.


    그런 다음 match 문을 사용하여 결과가 Ok인지 Err인지 확인하고, 각 경우에 따라 적절한 동작을 수행합니다.


    이 튜토리얼에서는 Rust의 오류 핸들링의 기본 사항만 다루었습니다.


    실제로는 `?` 연산자를 사용하여 오류를 전파하거나, 사용자 지정 오류 유형을 정의하는 등 더 많은 기능을 활용할 수 있습니다.


    이러한 고급 기능을 배우는 것도 도움이 될 것입니다.
- title: Chapter 1 - 마무리
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&code=%2F*%0A%EB%AC%B8%EC%A0%9C+1%0A%0A%3E+area%28shape%3A+Shape%29+-%3E+f64%0A%0A%ED%83%80%EC%9E%85%EC%9D%98+%EA%B0%92%EC%9D%B4+%EC%A3%BC%EC%96%B4%EC%A1%8C%EC%9D%84+%EB%95%8C%2C+%EA%B7%B8+%EB%8F%84%ED%98%95%EC%9D%98+%EB%84%93%EC%9D%B4%EB%A5%BC+%EA%B3%84%EC%82%B0%ED%95%B4%EC%84%9C+%EB%B0%98%ED%99%98%ED%95%98%EB%8A%94+%ED%95%A8%EC%88%98%EC%9E%85%EB%8B%88%EB%8B%A4.%0A%0A%EB%84%93%EC%9D%B4%EB%A5%BC+%EA%B3%84%EC%82%B0%ED%95%A0+%EB%95%8C%EB%8A%94+%ED%8C%8C%EC%9D%B4%28pi%29%EB%A5%BC+3.14%EB%A1%9C+%EA%B0%80%EC%A0%95%ED%95%A9%EB%8B%88%EB%8B%A4.+%EB%A7%8C%EC%95%BD+%EB%8F%84%ED%98%95%EC%9D%B4+%EC%82%BC%EA%B0%81%ED%98%95%EC%9D%B4%EA%B3%A0%0A%0A%EC%82%BC%EA%B0%81%ED%98%95%EC%9D%98+%EC%84%B8+%EB%B3%80%EC%9D%98+%EA%B8%B8%EC%9D%B4%EA%B0%80+%EC%82%BC%EA%B0%81%ED%98%95%EC%9D%84+%EB%A7%8C%EB%93%A4+%EC%88%98+%EC%97%86%EB%8A%94+%EA%B2%BD%EC%9A%B0%EC%97%90%EB%8A%94+%EC%97%90%EB%9F%AC%EB%A5%BC+%EB%B0%9C%EC%83%9D%EC%8B%9C%ED%82%A4%EC%84%B8%EC%9A%94.%0A%0A%3E+perimeter%28shape%3A+Shape%29+-%3E+f64%0A%0A%ED%83%80%EC%9E%85%EC%9D%98+%EA%B0%92%EC%9D%B4+%EC%A3%BC%EC%96%B4%EC%A1%8C%EC%9D%84+%EB%95%8C%2C+%EA%B7%B8+%EB%8F%84%ED%98%95%EC%9D%98+%EB%91%98%EB%A0%88%EB%A5%BC+%EA%B3%84%EC%82%B0%ED%95%B4%EC%84%9C+%EB%B0%98%ED%99%98%ED%95%98%EB%8A%94+%ED%95%A8%EC%88%98%EC%9E%85%EB%8B%88%EB%8B%A4.%0A%0A%EB%A7%8C%EC%95%BD+%EB%8F%84%ED%98%95%EC%9D%B4+%EC%82%BC%EA%B0%81%ED%98%95%EC%9D%B4%EA%B3%A0+%EC%82%BC%EA%B0%81%ED%98%95%EC%9D%98+%EC%84%B8+%EB%B3%80%EC%9D%98+%EA%B8%B8%EC%9D%B4%EA%B0%80+%EC%82%BC%EA%B0%81%ED%98%95%EC%9D%84+%EB%A7%8C%EB%93%A4+%EC%88%98+%EC%97%86%EB%8A%94+%EA%B2%BD%EC%9A%B0%EC%97%90%EB%8A%94+%EC%97%90%EB%9F%AC%EB%A5%BC+%EB%B0%9C%EC%83%9D%EC%8B%9C%ED%82%A4%EC%84%B8%EC%9A%94.%0A%0Ais_square%28shape%3A+Shape%29+-%3E+bool%0A%0A%ED%83%80%EC%9E%85%EC%9D%98+%EA%B0%92%EC%9D%B4+%EC%A3%BC%EC%96%B4%EC%A1%8C%EC%9D%84+%EB%95%8C%2C+%EA%B7%B8+%EB%8F%84%ED%98%95%EC%9D%B4+%EC%A0%95%EC%82%AC%EA%B0%81%ED%98%95%EC%9D%B8%EC%A7%80+%ED%8C%90%EB%B3%84%ED%95%B4%EC%84%9C+%EB%B0%98%ED%99%98%ED%95%98%EB%8A%94+%ED%95%A8%EC%88%98%EC%9E%85%EB%8B%88%EB%8B%A4.%0A%0A%EB%A7%8C%EC%95%BD+%EB%8F%84%ED%98%95%EC%9D%B4+%EC%82%AC%EA%B0%81%ED%98%95%EC%9D%B4+%EC%95%84%EB%8B%88%EB%A9%B4+false%EB%A5%BC+%EB%B0%98%ED%99%98%ED%95%98%EC%84%B8%EC%9A%94.%0A%0A%EB%8B%B5%EC%9D%80+%EB%A7%88%EC%A7%80%EB%A7%89+%EC%B1%95%ED%84%B0+%EB%B6%80%EB%A1%9D%EC%9D%84+%ED%99%95%EC%9D%B8%ED%95%98%EC%84%B8%EC%9A%94.%0A*%2F%0A%0Aenum+Shape+%7B%0A++++Circle%28f64%29%2C+++++++++++++%2F%2F+%EB%B0%98%EC%A7%80%EB%A6%84%0A++++Rectangle%28f64%2C+f64%29%2C+++++%2F%2F+%EA%B0%80%EB%A1%9C%2C+%EC%84%B8%EB%A1%9C%0A++++Triangle%28f64%2C+f64%2C+f64%29%2C+%2F%2F+%EC%84%B8+%EB%B3%80%EC%9D%98+%EA%B8%B8%EC%9D%B4%0A%7D%0A%0A%2F%2F+%EB%84%93%EC%9D%B4%EB%A5%BC+%EA%B3%84%EC%82%B0%ED%95%98%EB%8A%94+%ED%95%A8%EC%88%98%0Afn+area%28shape%3A+%26Shape%29+-%3E+f64+%7B%0A++++%2F%2F+FIXME%0A++++%2F%2F+perimeter+%ED%95%A8%EC%88%98%EB%A5%BC+%EC%B0%B8%EA%B3%A0%ED%95%98%EC%84%B8%EC%9A%94.%0A++++%2F%2F+%EC%97%90%EB%9F%AC+%EB%B0%9C%EC%83%9D%EC%9D%80+panic%21+%EB%A7%A4%ED%81%AC%EB%A1%9C%EB%A5%BC+%EC%82%AC%EC%9A%A9%ED%95%A0+%EC%88%98+%EC%9E%88%EC%8A%B5%EB%8B%88%EB%8B%A4.%0A%7D%0A%0A%2F%2F+%EB%91%98%EB%A0%88%EB%A5%BC+%EA%B3%84%EC%82%B0%ED%95%98%EB%8A%94+%ED%95%A8%EC%88%98%0Afn+perimeter%28shape%3A+%26Shape%29+-%3E+f64+%7B%0A++++match+shape+%7B%0A++++++++Shape%3A%3ACircle%28r%29+%3D%3E+2.0+*+3.14+*+r%2C%0A++++++++Shape%3A%3ARectangle%28w%2C+h%29+%3D%3E+2.0+*+%28w+%2B+h%29%2C%0A++++++++Shape%3A%3ATriangle%28a%2C+b%2C+c%29+%3D%3E+%7B%0A++++++++++++%2F%2F+%EC%82%BC%EA%B0%81%ED%98%95%EC%9D%98+%EB%91%98%EB%A0%88+%EA%B3%B5%EC%8B%9D%0A++++++++++++let+p+%3D+a+%2B+b+%2B+c%3B%0A++++++++++++%2F%2F+%EB%91%98%EB%A0%88%EA%B0%80+%EC%9D%8C%EC%88%98%EB%A9%B4+%EC%97%90%EB%9F%AC+%EB%B0%9C%EC%83%9D%0A++++++++++++if+p+%3C+0.0+%7B%0A++++++++++++++++panic%21%28%22Invalid+triangle%22%29%3B%0A++++++++++++%7D+else+%7B%0A++++++++++++++++p%0A++++++++++++%7D%0A++++++++%7D%0A++++%7D%0A%7D%0A%0A%2F%2F+%EC%A0%95%EC%82%AC%EA%B0%81%ED%98%95%EC%9D%B8%EC%A7%80+%ED%8C%90%EB%B3%84%ED%95%98%EB%8A%94+%ED%95%A8%EC%88%98%0Afn+is_square%28shape%3A+%26Shape%29+-%3E+bool+%7B%0A++++match+shape+%7B%0A++++++++Shape%3A%3ACircle%28_%29+%3D%3E+false%2C%0A++++++++%2F%2F+FIXME+%EB%8B%A4%EB%A5%B8+%EB%8F%84%ED%98%95...%0A++++%7D%0A%7D%0A%0A%2F%2F+%EA%B2%B0%EA%B3%BC%0A%2F*%0A%EC%9B%90+%EB%84%93%EC%9D%B4%3A+12.56%0A%EC%82%AC%EA%B0%81%ED%98%95+%EB%84%93%EC%9D%B4%3A+12%0A%EC%82%BC%EA%B0%81%ED%98%95+%EB%84%93%EC%9D%B4%3A+6%0A%EC%9B%90+%EB%91%98%EB%A0%88%3A+12.56%0A%EC%82%AC%EA%B0%81%ED%98%95+%EB%91%98%EB%A0%88%3A+14%0A%EC%82%BC%EA%B0%81%ED%98%95+%EB%91%98%EB%A0%88%3A+12%0A%EC%9B%90%EC%9D%B4+%EC%A0%95%EC%82%AC%EA%B0%81%ED%98%95%EC%9D%B8%EA%B0%80%3F+false%0A%EC%82%AC%EA%B0%81%ED%98%95%EC%9D%B4+%EC%A0%95%EC%82%AC%EA%B0%81%ED%98%95%EC%9D%B8%EA%B0%80%3F+false%0A%EC%82%BC%EA%B0%81%ED%98%95%EC%9D%B4+%EC%A0%95%EC%82%AC%EA%B0%81%ED%98%95%EC%9D%B8%EA%B0%80%3F+false%0A*%2F%0Afn+main%28%29+%7B%0A++++%2F%2F+Shape+%ED%83%80%EC%9E%85%EC%9D%98+%EA%B0%92%EB%93%A4%EC%9D%84+%EC%83%9D%EC%84%B1%ED%95%A9%EB%8B%88%EB%8B%A4.%0A++++let+circle+%3D+Shape%3A%3ACircle%282.0%29%3B%0A++++let+rectangle+%3D+Shape%3A%3ARectangle%283.0%2C+4.0%29%3B%0A++++let+triangle+%3D+%2F%2F+FIXME%3B%0A%0A++++%2F%2F+%EA%B0%81+%EB%8F%84%ED%98%95%EC%9D%98+%EB%84%93%EC%9D%B4%EB%A5%BC+%EC%B6%9C%EB%A0%A5%ED%95%A9%EB%8B%88%EB%8B%A4.%0A++++println%21%28%22%EC%9B%90+%EB%84%93%EC%9D%B4%3A+%7B%7D%22%2C+area%28%26circle%29%29%3B%0A++++println%21%28%22%EC%82%AC%EA%B0%81%ED%98%95+%EB%84%93%EC%9D%B4%3A+%7B%7D%22%2C+area%28%26rectangle%29%29%3B%0A++++println%21%28%22%EC%82%BC%EA%B0%81%ED%98%95+%EB%84%93%EC%9D%B4%3A+%7B%7D%22%2C+area%28%26triangle%29%29%3B%0A%0A++++%2F%2F+%EA%B0%81+%EB%8F%84%ED%98%95%EC%9D%98+%EB%91%98%EB%A0%88%EB%A5%BC+%EC%B6%9C%EB%A0%A5%ED%95%A9%EB%8B%88%EB%8B%A4.%0A++++println%21%28%22%EC%9B%90+%EB%91%98%EB%A0%88%3A+%7B%7D%22%2C+perimeter%28%26circle%29%29%3B%0A++++println%21%28%22%EC%82%AC%EA%B0%81%ED%98%95+%EB%91%98%EB%A0%88%3A+%7B%7D%22%2C+perimeter%28%26rectangle%29%29%3B%0A++++println%21%28%22%EC%82%BC%EA%B0%81%ED%98%95+%EB%91%98%EB%A0%88%3A+%7B%7D%22%2C+perimeter%28%26triangle%29%29%3B%0A%0A++++%2F%2F+%EA%B0%81+%EB%8F%84%ED%98%95%EC%9D%B4+%EC%A0%95%EC%82%AC%EA%B0%81%ED%98%95%EC%9D%B8%EC%A7%80+%EC%B6%9C%EB%A0%A5%ED%95%A9%EB%8B%88%EB%8B%A4.%0A++++println%21%28%22%EC%9B%90%EC%9D%B4+%EC%A0%95%EC%82%AC%EA%B0%81%ED%98%95%EC%9D%B8%EA%B0%80%3F+%7B%7D%22%2C+is_square%28%26circle%29%29%3B%0A++++println%21%28%22%EC%82%AC%EA%B0%81%ED%98%95%EC%9D%B4+%EC%A0%95%EC%82%AC%EA%B0%81%ED%98%95%EC%9D%B8%EA%B0%80%3F+%7B%7D%22%2C+is_square%28%26rectangle%29%29%3B%0A++++println%21%28%22%EC%82%BC%EA%B0%81%ED%98%95%EC%9D%B4+%EC%A0%95%EC%82%AC%EA%B0%81%ED%98%95%EC%9D%B8%EA%B0%80%3F+%7B%7D%22%2C+is_square%28%26triangle%29%29%3B%0A%7D%0A
  content_markdown: >
    Rust의 기초는 그렇게 나쁘지 않죠?


    시스템 프로그래밍 언어로서, Rust는 메모리 내 값을 매우 신경쓰며,


    수정이 가능한지 불가능한지 여부, 그리고 수학 연산이 의도한 대로 수행되는지 확인합니다.



    참고:

    * [Youtube: Rust Cast - Rust의 기본 숫자 유형에 대한 더 깊은 이해](https://www.youtube.com/watch?v=n5TRBkbystY)

    * [Website: Rust Book 2018 - 기본 데이터 유형에 대한 자세한 설명](https://doc.rust-lang.org/1.30.0/book/2018-edition/ch03-02-data-types.html)

    * [Website: Rust Cheat Sheet - Data Types](https://cheats.rs/#basic-types)

    <div>
    <button type="button" class="collapsible">정답 보기</button>
    <div class="content">
    %rust%

    enum Shape {
        Circle(f64),             // 반지름
        Rectangle(f64, f64),     // 가로, 세로
        Triangle(f64, f64, f64), // 세 변의 길이
    }


    // 넓이를 계산하는 함수

    fn area(shape: &Shape) -> f64 {
        match shape {
            Shape::Circle(r) => 3.14 * r * r,
            Shape::Rectangle(w, h) => w * h,
            Shape::Triangle(a, b, c) => {
                // 삼각형의 넓이 공식
                let s = (a + b + c) / 2.0;
                let area = s * (s - a) * (s - b) * (s - c);
                // 넓이가 음수면 에러 발생
                if area < 0.0 {
                    panic!("Invalid triangle");
                } else {
                    area.sqrt()
                }
            }
        }
    }


    // 둘레를 계산하는 함수

    fn perimeter(shape: &Shape) -> f64 {
        match shape {
            Shape::Circle(r) => 2.0 * 3.14 * r,
            Shape::Rectangle(w, h) => 2.0 * (w + h),
            Shape::Triangle(a, b, c) => {
                // 삼각형의 둘레 공식
                let p = a + b + c;
                // 둘레가 음수면 에러 발생
                if p < 0.0 {
                    panic!("Invalid triangle");
                } else {
                    p
                }
            }
        }
    }


    // 정사각형인지 판별하는 함수

    fn is_square(shape: &Shape) -> bool {
        match shape {
            Shape::Circle(_) => false,
            Shape::Rectangle(w, h) => w == h,
            Shape::Triangle(_, _, _) => false,
        }
    }


    // 결과

    /*

    원 넓이: 12.56

    사각형 넓이: 12

    삼각형 넓이: 6

    원 둘레: 12.56

    사각형 둘레: 14

    삼각형 둘레: 12

    원이 정사각형인가? false

    사각형이 정사각형인가? false

    삼각형이 정사각형인가? false

    */

    fn main() {
        // Shape 타입의 값들을 생성합니다.
        let circle = Shape::Circle(2.0);
        let rectangle = Shape::Rectangle(3.0, 4.0);
        let triangle = Shape::Triangle(3.0, 4.0, 5.0);

        // 각 도형의 넓이를 출력합니다.
        println!("원 넓이: {}", area(&circle));
        println!("사각형 넓이: {}", area(&rectangle));
        println!("삼각형 넓이: {}", area(&triangle));

        // 각 도형의 둘레를 출력합니다.
        println!("원 둘레: {}", perimeter(&circle));
        println!("사각형 둘레: {}", perimeter(&rectangle));
        println!("삼각형 둘레: {}", perimeter(&triangle));

        // 각 도형이 정사각형인지 출력합니다.
        println!("원이 정사각형인가? {}", is_square(&circle));
        println!("사각형이 정사각형인가? {}", is_square(&rectangle));
        println!("삼각형이 정사각형인가? {}", is_square(&triangle));
    }

    %end%
    </div>
    </div>
